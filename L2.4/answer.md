### Ответ на L2.4

Программа выведет: 
```bash
0
1
2
3
4
5
6
7
8
9
fatal error: all goroutines are asleep - deadlock!
```

---

#### Порядок выполнения

1. `ch := make(chan int)` - объявляем небуферизированный канал;
2. 
    ```go
	go func() {
		for i := 0; i < 10; i++ {
			ch <- i
		}
	}()
    ```
    - запускается горутина, которая отправлет в канал числа от 0 до 9. **Канал блокируется, пока из него кто-то не прочитает**;

3. 
    ```go
	for n := range ch {
		println(n)
	}
    ```
    - `for n := range ch` - читает новые значения из канала до тех пор, пока **он не будет закрыт**.

4. В выводе происходит чтение из канала, затем deadlock.

---

### Объяснение проблемы

Deadlock произошел, потому что:
- после завершения горутины - канал остается открытым;
- процесс чтения из канала ждет новые значения или сигнал закрытия;
- планировщик Go видит, что все горутины остановились и ждут, затем вызывает Deadlock.  

---

### Вариант испраления

Исправить данный код можно при помощи передачи сигнала закрытия канала после отправки данных:

```go
func main() {
	ch := make(chan int)
	go func() {
		for i := 0; i < 10; i++ {
			ch <- i
		}
        close(ch)
	}()
	for n := range ch {
		println(n)
	}
}
```