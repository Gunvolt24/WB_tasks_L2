### Ответ на L2.6

---
Источники информации:
1. https://github.com/golang/go/blob/master/src/runtime/slice.go 
2. https://go.dev/ref/spec#Appending_and_copying_slices
3. https://habr.com/ru/companies/yadro/articles/874480/
4. https://ru.stackoverflow.com/questions/1570354/append-%D0%B8-%D0%BC%D1%83%D1%82%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D0%BE%D1%81%D1%82%D1%8C-%D1%81%D0%BB%D0%B0%D0%B9%D1%81%D0%B0

---

Программа выведет: 
`[3 2 3]`

---
#### Прежде чем отвечать на задачу - нужно объяснить теорию по слайсам :D

##### 1. Что из себя представляет слайс?

- Смотрим на структуру слайса в рантайме:
```go
// https://github.com/golang/go/blob/master/src/runtime/slice.go

type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
```
- Тут мы можем увидеть, что слайс из себя представляет из себя структуру, где его элементами являются:
	1. `array` - указатель на (базовый) массив. Или еще говорят, указатель на память;
	2. `len` - длина слайса - показывает сколько ячеек в массиве заполнено;
	3. `cap` - объем слайса - показывает сколько мы можем поместить элементов в слайс без выделения новой памяти.

Еще слайс называют **динамическим массивом**, потому что он обладает способностью расти по мере заполнения.

##### 2. Как работает append в слайсе?

- `append` - это функция, которая позволяет добавить 0 или больше элементов в конеца слайса определенного типа и возвращает слайс того же типа:
```go
func append(slice []Type, elems ...Type) []Type
```

##### 2.1. Как происходит наполнение слайса при append?

1. Предположим, есть пустой слайс:
```go
var myslice []int

// внутри слайс из себя представляет:
array=nil
len=0
cap=0
```

2. Добавим элемент №1:
```go
myslice := append(myslice, 15)

// теперь внутри он из себя представляет:
array=[15]
len=1
cap=1
```

- Здесь происходит аллокация под один элемент.

3. Теперь добавим элемент №2 в тот же слайс:
```go
myslice := append(myslice, 16)

// теперь внутри он из себя представляет:
array=[15, 16]
len=2
cap=2
```
- Тут произошло следующее:
	1. Слайс с элементом №1 имеет `len=1, cap=1` - является заполненным - данные в слайс не поместить, объем `cap` позволяет;
	2. При `append` в слайс элемента №2 - поскольку объема `cap` недостаточно - сам `append` **аллоцирует новый базовый массив**, который сможет поместить в себе существующий слайс и добавлемые в него элементы. 
	- *С другой стороны, если объема `cap` достаточно - при `append` он добавит новые элементы в конец слайса, ссылаясь на **старый базовый массив**.* 

4. Что произойдет, если добавить элемент №3 в тот же слайс?
```go
myslice := append(myslice, 17)

// теперь внутри он из себя представляет:
array=[15, 16, 17, _ ]
len=3
cap=4
```
- Здесь можно заметить, что `cap` увеличился в 2 раза. Почему так произошло?

Ответ лежит, опять же, в рантайме языка, где можно посмотреть как происходит увеличение `cap`:

```go
// https://github.com/golang/go/blob/master/src/runtime/slice.go

// nextslicecap computes the next appropriate slice length.
func nextslicecap(newLen, oldCap int) int {
	newcap := oldCap
	doublecap := newcap + newcap
	if newLen > doublecap {
		return newLen
	}

	const threshold = 256
	if oldCap < threshold {
		return doublecap
	}
	for {
		// Transition from growing 2x for small slices
		// to growing 1.25x for large slices. This formula
		// gives a smooth-ish transition between the two.
		newcap += (newcap + 3*threshold) >> 2
		...
```
- Другими словами, в самом рантайме видно, что:
	1. Стоит ограничение на количество элементов в слайсе: `const threshold = 256`;
	2. И есть специальная формула, c условием:
		- **если в слайсе `cap` элементов было меньше 256, то вместимость увеличивается в два раза**;
		- **если больше 256, то на четверть.**

Таким образом, происходит увеличение объема в слайсе.

#### 3. Особенности передачи слайса в функцию

[ [1. Готовим слайсы в Go: подробно о динамических массивах, строчках и ускорении](https://habr.com/ru/companies/yadro/articles/874480/) ] 

"Передать слайс в функцию можно двумя способами:
- По значению — при передаче внутри функции получаем новый слайс, но указывает он на ту же самую память.

- По указателю — передается адрес оригинального слайса. 

Если будем передавать слайс по значению, то внутри функции будет новый слайс со своими length и capacity, но указатель на сами элементы будет показывать на ту же область, что и слайс снаружи. И если мы поменяем внутри функции эти элементы, то снаружи, когда выйдем из функции, увидим эту модификацию в оригинальном слайсе. 

**Если мы попытаемся добавить новые элементы внутри функции, то мы не увидим эти изменения снаружи, так как не изменится length и capacity снаружи.** 

Передача по указателю на микросекунды быстрее, потому что передается 8 байт вместо 24. Но у должна быть очень веская причина, чтобы так делать — лучше все передавать по значению."

===

Еще одно очень хорошее объяснение с особенностями передачи слайса в функцию можно найти тут:
[2. append и мутируемость слайса](https://ru.stackoverflow.com/questions/1570354/append-%D0%B8-%D0%BC%D1%83%D1%82%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D0%BE%D1%81%D1%82%D1%8C-%D1%81%D0%BB%D0%B0%D0%B9%D1%81%D0%B0)

---

#### Что происходит в задаче

Для наглядности, выведем `len`, `cap`, указатели и адреса слайсов:

```go
func main() {
	var s = []string{"1", "2", "3"}
	fmt.Println("main (before): ", s, len(s), cap(s))
	fmt.Printf("main (before): %p->%p\n", &s, s)
	modifySlice(s)
	fmt.Println("main (after): ", s, len(s), cap(s))
	fmt.Printf("main (after): %p->%p\n", &s, s)
	fmt.Println(s)
}

func modifySlice(i []string) {
	fmt.Println("  modifySlice (i): ", i, len(i), cap(i))
	fmt.Printf("  modifySlice (i): %p->%p\n", &i, i)
	i[0] = "3"
	fmt.Println("  modifySlice (i[0] = 3): ", i, len(i), cap(i))
	fmt.Printf("  modifySlice (i[0] = 3): %p->%p\n", &i, i)
	i = append(i, "4")
	fmt.Println("  modifySlice (append 4): ", i, len(i), cap(i))
	fmt.Printf("  modifySlice (append 4): %p->%p\n", &i, i)
	i[1] = "5"
	fmt.Println("  modifySlice: i[1] = 5", i, len(i), cap(i))
	fmt.Printf("  modifySlice i[1] = 5: %p->%p\n", &i, i)
	i = append(i, "6")
	fmt.Println("  modifySlice (append 6): ", i, len(i), cap(i))
	fmt.Printf("  modifySlice (append 6): %p->%p\n", &i, i)
}
```

Вывод:

```bash
$ go run L2.6/main.go
main:  [1 2 3] 3 3
main: 0xc000008030->0xc00002c180
  modifySlice:  [1 2 3] 3 3
  modifySlice: 0xc000008078->0xc00002c180
  modifySlice:  [3 2 3] 3 3
  modifySlice: 0xc000008078->0xc00002c180
  modifySlice:  [3 2 3 4] 4 6
  modifySlice: 0xc000008078->0xc00003c0c0
  modifySlice:  [3 5 3 4] 4 6
  modifySlice: 0xc000008078->0xc00003c0c0
  modifySlice:  [3 5 3 4 6] 5 6
  modifySlice: 0xc000008078->0xc00003c0c0
main:  [3 2 3] 3 3
main: 0xc000008030->0xc00002c180
[3 2 3]

voron@Andrey MINGW64 /d/Projects/GoProjects/WB_tasks_L2 (main)
$ go run L2.6/main.go
main (before):  [1 2 3] 3 3
main (before): 0xc000008030->0xc00002c180
  modifySlice (i):  [1 2 3] 3 3
  modifySlice (i): 0xc000008078->0xc00002c180
  modifySlice (i[0] = 3):  [3 2 3] 3 3
  modifySlice (i[0] = 3): 0xc000008078->0xc00002c180
  modifySlice (append 4):  [3 2 3 4] 4 6
  modifySlice (append 4): 0xc000008078->0xc00003c0c0
  modifySlice: i[1] = 5 [3 5 3 4] 4 6
  modifySlice i[1] = 5: 0xc000008078->0xc00003c0c0
  modifySlice (append 6):  [3 5 3 4 6] 5 6
  modifySlice (append 6): 0xc000008078->0xc00003c0c0
main (after):  [3 2 3] 3 3
main (after): 0xc000008030->0xc00002c180
[3 2 3]
```

- В функции main мы видим, что пременная `s` находится по адресу `0xc000008030`, указатель на данные `0xc00002c180`;
- В функции `modifySlice` - работа происходит с копией слайса (=> новая аллокация), которая находится по другому адресу `0xc000008078`, но указывает на тот же базовый массив `0xc00002c180`;
- `i[0] = "3"` - изменяем первый элемент слайса - работа с копией `0xc000008078`, но с указателем на тот же базовый массив `0xc00002c180` => изменения отобразятся в исходном слайсе.
- `i = append(i, "4")` - поскольку объема `cap` не хватает (`cap=3`) `append` выделяет новый массив и увеличивает объем слайса в 2 раза => `[3 2 3 4] (len=4, cap=6)`. Работа происходит с той же копией слайса `0xc000008078`, но с новым указателем на новый массив `0xc00003c0c0` => все изменения происходят внутри функции и на исходный слайс уже не повлияют, т.к. они уже работают с новым массивом, который указывает на `0xc00003c0c0`. 



