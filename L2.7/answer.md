### Ответ на L2.7

---
Источники информации:
1. https://habr.com/ru/articles/896940/ 
2. https://go.dev/ref/spec#Select_statements
3. https://habr.com/ru/articles/490336/
4. https://www.codingexplorations.com/blog/mastering-nil-channels-in-go-enhance-your-concurrency-control 


---

Программа выведет: 
**Числа от 1 до 8 включительно, но в случайном порядке**

---

#### Что такое оператор select?

[[1.]](https://habr.com/ru/articles/896940/)

Оператор `select` в Go - это управляющая структура, которая работает с несколькими операциями над каналами, предоставляя возможность выполнять операцию для первого готового канала. Он похож на оператор switch, но предназначен для работы с каналами.


Оператор `select` может содержать несколько веток `case`, каждая из которых обрабатывает различные операции с каналами - отправку или получение данных. Среда выполнения Go оценивает оператор `select` и выполняет первую ветку, где операция с каналом может быть выполнена. Если несколько операций готовы к выполнению, одна из них выбирается случайным образом.

---

#### Объяснение кода

1. Функция main:
```go
func main() {
	rand.Seed(time.Now().Unix())
	a := asChan(1, 3, 5, 7)
	b := asChan(2, 4, 6, 8)
	c := merge(a, b)
	for v := range c {
		fmt.Print(v)
	}
}
```

1.1. `rand.Seed(time.Now().Unix())` - сид для генераций псевдо-случайных чисел;
1.2. 
``` go
	a := asChan(1, 3, 5, 7)
	b := asChan(2, 4, 6, 8)
```
- вызываем функцию `asChan` и передаем в нее числа. Два вызова функций храним в переменных `a` и `b`;
1.3. `c := merge(a, b)` - вызываем функцию `merge` и передаем в нее функции из переменных `a` и `b`. Вызов функции храним в переменной `c`;
1.4.
```go
	for v := range c {
		fmt.Print(v)
	}
}
```
- выводим результат из функции `merge`.

---

2. Функция `asChan`:
```go
func asChan(vs ...int) <-chan int {
	c := make(chan int)
	go func() {
		for _, v := range vs {
			c <- v
			time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
		}
		close(c)
	}()
	return c
}
```

2.1. `func asChan(vs ...int) <-chan int {` - функция `asChan`:
- принимет неопределенное количество значений типа `int` - `vs ...int`;
- возвращает читающий канал `<-chan int`.

2.2. `c := make(chan int)` - создаем небуферизированный канал типа `int` для хранения результата;
2.3. 
```go
	go func() {
		for _, v := range vs {
			c <- v
			time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
		}
		close(c)
	}()
	return c
}
```

- `go func() {` - запускаем анонимную горутину;
- 
	```go
		for _, v := range vs {
			c <- v
	```
	- значения из `vs` записываем в канал `c`;
-  `time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)` - имитируем задержку записи в канал, длительность которой генерируется псевдо-случайно в пределах от 0 до 1000;
- `close(c)` - закрываем канал;
- `return c` - возвращаем канал `c`.

---
3. Функция `merge`:

```go
func merge(a, b <-chan int) <-chan int {
	c := make(chan int)
	go func() {
		for {
			select {
			case v, ok := <-a:
				if ok {
					c <- v
				} else {
					a = nil
				}
			case v, ok := <-b:
				if ok {
					c <- v
				} else {
					b = nil
				}
			}
			if a == nil && b == nil {
				close(c)
				return
			}
		}
	}()
	return c
}
```
3.1. `func merge(a, b <-chan int) <-chan int {` - фунцкия `merge`:
- принимает читаемые каналы `a` и `b`;
- возвращает читающий канал.

3.2. `c := make(chan int)` - создаем небуферизированный канал типа `int` для хранения результата;
3.3. 
```go
go func() {
		for {
```
- запускаем анонимную горутину и бесконечный цикл;

3.4. `select {` - делаем `select`, где:
```go
			case v, ok := <-a:
				if ok {
					c <- v
				} else {
					a = nil
				}
			case v, ok := <-b:
				if ok {
					c <- v
				} else {
					b = nil
				}
			}
```
- оба `case` работают идентично: читают из соответствующего канала `a` и `b`, и пока в них можно прочитать значения (пока `ok == true`) - записываем значения в результатирующий канал `c`. Как только прочитаны все элементы из каналов => `ok == false` - приравниваем каналы в `nil`.
**Тут важно учитывать 2 вещи:** 
**1. Если данные приходят одновременно из двух и более каналов, то тогда один из неблокируемых `case` будет выбран случайным образом [[3]](https://habr.com/ru/articles/490336/);** 
**2. Любые операции с `nil` каналами в `select` игнорируются (он просто не будет выбран). Если все каналы в `select` находятся в состоянии `nil` - то `case` в `select` блокируется до тех пор, пока хотя бы один канал станет `non-nil` [[4]](https://www.codingexplorations.com/blog/mastering-nil-channels-in-go-enhance-your-concurrency-control)**.
	##### В рамках задачи это означает, что мы **динамически контролируем работу выполнение горутины. Устанавливая канал в значение `nil` - мы эффективно исключаем выбор `case` в `select` до тех пор, пока оба `case` не станут `nil`, тем самым корректно завершая работу `select`** 

3.5. 
```go
			if a == nil && b == nil {
				close(c)
				return
			}
		}
	}()
	return c
```
- как только оба канала становятся в состоянии `nil` -> закрываем и возвращаем читающий канал `c`.

---
#### TLDR:
1. Из `main` отправляем данные в функцию `asChan` из двух источников `a` и `b`;
2. В функции `asChan` записываем принимаемые данные в канал, и делаем случайную паузу между отправками;
3. Возвращаемые каналы из `asChan`, хранящиеся в переменных `a` и `b` принимаются в функции `merge`;
4. В фунции `merge`: 
	4.1. Создаем результатирующий канал `c`;  
	4.2. Запускаем горутину с бесконечным циклом и `select`, где:
	- в двух `case` записываем данные в результатирующий канал `c` и по завершению записи делаем `case` блокирующим. Данный подход позволяет управлять поведением `select`, блокируя и разблокирую блоки `case` по мере готовности.

**Результат получается разным потому что:**

- `asChan` вставляет случайные задержки `(rand.Intn(1000))` -> чтение из `a` и `b` происходит с непредсказуемыми интервалами;
- `select` отдаёт предпочтение тому `case`, который готов первым. При одновременной готовности выбор случайный;
- В следствии этого - элементы с `a` и `b` перемешиваются в произвольном порядке.